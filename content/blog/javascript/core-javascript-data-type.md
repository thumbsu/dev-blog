---
title: '[코어 자바스크립트] 데이터 타입'
date: 2020-10-21 12:10:15
category: javascript
thumbnail: { thumbnailSrc }
draft: false
---

> [코어 자바스크립트] 읽고, 다시 한번 읽으며 정리한 내용입니다.
>
> "@~" 이런 문자는 데이터 주소를 의미하며 이후의 숫자는 책에 예시이므로 과정만 따라가면 됩니다.

## 🧬 메모리와 데이터

### 메모리와 비트

- 메모리는 **매우 많은 비트들로 구성**
- 비트는 **0 또는 1만 표현할 수 있는 하나의 메모리 조각**
- 각 비트는 **고유한 식별자**를 통해 위치를 확인
- 0과 1만 표현할 수 있는 비트 단위로 위치 확인을 하는 것은 비효율적
- **몇 개씩 묶어 하나의 단위**로 여기는 것이 더 효율적일 것

### 바이트

- 1바이트는 8개의 비트로 구성
- 1비트마다 두 가지 값 표현하므로 **1바이트는 총 256개** 값 표현 가능

### 자바스크립트의 메모리 관리

- 메모리 용량이 과거보다 월등히 커진 상황에서 등장
- C/C++, 자바 등등의 언어보다 상대적으로 메모리 관리에 대한 압박에 자유로움
- **숫자는 8바이트 확보**하고 정수형, 부동소수형 구분 안함

### 데이터의 구분

- 바이트는 시작하는 비트의 식별자로 위치 파악
- 더 정확히는 **메모리 주소값**을 통해 서로 구분하고 연결 가능

## 🏷 식별자와 변수

- 변수는 **변할 수 있는 데이터**
- 식별자는 어떤 데이터를 식별하는 데 사용하는 이름, 즉 **변수명**

### 변수 선언시 컴퓨터가 메모리 영역에서 수행하는 작업

- **"변할 수 있는 데이터를 만들건데, 이 데이터의 식별자는 a로 하자!"**

```javascript
var a
```

- 메모리에서 비어있는 공간 하나 확보
- 공간의 이름(식별자)를 a라고 지정

### 데이터 할당

```javascript
var a
a = 'abc'
```

- a라는 이름을 가진 주소에 문자열 'abc'를 **직접 저장하지 않음**
- 데이터를 저장하기 위한 별도의 메모리 공간을 확보해서 'abc' 저장
- 그 주소를 변수 영역에 저장하는 식

### 데이터 할당의 전체 흐름

- 변수 영역에서 빈 공간 확보
- 확보된 공간의 식별자를 a로 지정
- 데이터 영역의 빈 공간에 문자열 'abc' 저장
- 변수 영역에서 a라는 식별자 검색
- a라는 식별자를 가진 공간에 문자열이 저장된 주소 대입

### 직접 대입하지 않고 한 단계를 더 거치는 이유

- 데이터 변환을 자유롭게 할 수 있게 함
- 메모리를 더욱 효과적으로 관리하기 위한 고민의 결과

### 문자열 데이터와 메모리

- 자바스크립트는 문자열 데이터에 특별히 정해진 규격이 없음
- 미리 확보된 공간 내에서만 데이터 변환을 할 수 있다면?
- 변환한 데이터를 다시 저장하기 위해서는 **"확보된 공간을 변환된 데이터 크기에 맞게 늘리는 작업"**이 선행되어야 함
- 즉, 컴퓨터가 처리해야 할 연산이 많아짐
- 따라서 효율적으로 문자열 데이터의 변환을 처리하려면 **변수와 데이터를 별도의 공간에 나누어 저장**
- 변수와 데이터의 영역을 분리하면 중복된 데이터에 대한 처리 효율이 높아짐

### 문자열 데이터의 변환

- **기존 문자열에 어떤 변환을 가하든 상관 없이 무조건 새로 만들어 별도의 공간에 저장**

```javascript
var a
a = 'abc'
a += 'def'
```

- 데이터 영역에 'abcdef'라는 문자열을 새로 만들어 별도의 공간에 저장
- 변수 영역에서 a라는 식별자 검색
- 그곳에 'abcdef'의 주소를 연결

## 💍 불변값 vs 가변값 vs 변수 vs 상수

- 불변값과 상수는 같은 개념이 아님

### 변수와 상수

- 변수와 상수를 구분하는 성질은 "변경 가능성"
- 변수와 상수를 구분 짓는 "변경 가능성"의 대상은 **변수 영역** 메모리
- 바꿀 수 있으면 _변수_
- 바꿀 수 없으면 _상수_
- 한 번 데이터 할당이 이뤄진 변수 공간에 다른 데이터를 재할당할 수 있는지 여부가 관건

### 불변값

- 불변성 여부를 구분할 때의 "변경 가능성"의 대상은 **데이터 영역** 메모리
- 기본형 데이터인 *숫자, 문자열, boolean, null, undefined, Symbol*은 불변값

### 불변성

- 한번 만든 값을 바꿀 수 없음
- 변경은 새로 만드는 동작을 통해서 이뤄짐
- 한번 만들어진 값은 가비지 컬렉팅을 당하지 않는 한 영원히 변하지 않음

```javascript
var a = 'abc'
a += 'def'
```

- 변수 a에 문자열 'abc'를 할당했다가 'def'를 추가
- 기존의 'abc'가 'abcdef'로 바뀌는 것이 아님
- 새로운 문자열 'abcdef'을 만들고 그 주소를 변수 a에 저장
- 'abc'와 'abcdef'는 완전히 별개의 데이터

```javascript
var b = 5
var c = 5
b = 7
```

- (1번째 줄) 변수 영역에 빈 공간 확보 후 식별자로 b 지정
- 데이터 영역에서 5를 찾음
- 없으면 데이터 공간을 하나 만들어 5 저장
- 그 주소를 b에 저장
- (2번째 줄) 변수 영역에 빈 공간 확보 후 식별자로 c 지정
- 데이터 영역에서 5를 찾음
- 이미 만들어 놓은 5의 주소를 재활용함
- (3번째 줄) 기존에 저장한 7이 있는지 확인 후 없으면 새로 만들어서 그 주소를 b에 저장

### 참조형 데이터의 할당

```javascript
var obj1 = {
  a: 1,
  b: 'bbb',
}
```

- 변수 영역 빈 공간(`@1002`)을 확보하고 그 주소 이름(식별자)을 `obj1`로 지정
- `obj1`의 데이터를 저장하기 위해 데이터 영역에 빈 공간(`@5001`)을 확보
- `obj1`에 할당하려는 데이터는 여러 개의 프로퍼티로 이뤄진 데이터 그룹
- 데이터 그룹 내부의 프로퍼티들을 저장하기 위한 별도의 변수 영역(`@7103 ~ ?`) 마련
- 그 별도의 변수 영역의 주소를 `@5001`에 저장
- `@7103`에 프로퍼티 이름 a 지정
- `@7104`에 프로퍼티 이름 b 지정
- 데이터 영역에서 숫자 1 검색
- 1이 없으므로 데이터 영역의 빈 공간 `@5003`에 1을 저장
- `@7103`에 `@5003` 저장
- 데이터 영역에서 문자열 'bbb' 검색
- 'bbb'가 없으므로 데이터 영역의 빈 공간 `@5004`에 저장
- `@7104`에 `@5004` 저장

### 기본형 데이터와 참조형 데이터

- **"객체의 변수(프로퍼티) 영역"이 별도로 존재한다는 점**
- 객체가 별도로 할애한 영역은 **"변수 영역"**
- "데이터 영역"은 기존의 메모리 공간을 그대로 활용
- 데이터 영역에 저장된 값은 모두 **불변값**
- **변수에는 다른 값을 얼마든지 대입할 수 있기 때문에 흔히 참조형 데이터는 불변하지 않다고 하는 것**

### 참조형 데이터의 프로퍼티에 참조형 데이터를 할당하는 경우

- 중첩 객체라고 함

```javascript
var obj = {
  x: 3,
  arr: [3, 4, 5],
}
```

- 변수 영역 빈 공간(`@1002`)을 확보하고 그 주소의 이름을 `obj`로 지정
- `obj`의 데이터를 저장하기 위해 데이터 영역의 빈 공간(`@5001`)을 확보
- `obj`에 할당하려는 데이터는 여러 개의 프로퍼티로 이뤄진 데이터 그룹
- 데이터 그룹 내부의 프로퍼티들을 저장하기 위한 별도의 변수 영역(`@7103 ~ ?`) 마련
- 그 별도의 변수 영역의 주소를 `@5001`에 저장
- `@7103`에 프로퍼티 이름 x 지정
- `@7104`에 프로퍼티 이름 arr 지정
- 데이터 영역에서 숫자 3 검색
- 3이 없으므로 데이터 영역의 빈 공간 `@5002`에 1을 저장
- `@7103`에 `@5002` 저장
- `@7104`에 저장할 데이터는 `obj`와 마찬가지로 데이터 그룹
- 데이터 그룹 내부의 프로퍼티들을 저장하기 위한 별도의 변수 영역(`@8104 ~ ?`) 마련
- 그 별도의 변수 영역의 주소를 `@5003`에 저장
- `@7104`에 `@5003` 저장
- `arr`의 배열의 요소가 3개이므로 3개의 변수 공간을 확보하고 각각 인덱스 부여
- 데이터 영역에서 숫자 3 검색(`@5002`)해서 그 주소를 `@8104`에 저장
- 데이터 영역에 숫자 4가 없으므로 `@5004`에 저장하고 이 주소를 `@8105`에 저장
- 데이터 영역에 숫자 5가 없으므로 `@5005`에 저장하고 이 주소를 `@8106`에 저장

### 중첩 객체에 재할당 명령을 내리면?

```javascript
obj.arr = 'str'
```

- 데이터 영역에 빈 공간 `@5006`에 문자열 'str' 저장
- 그 주소를 `@7104`에 저장
- `@5003`은 더이상 자신의 주소를 참조하는 변수가 없게 됨

### 참조 카운트와 가비지 컬렉터

- 어떤 데이터에 대해 자신의 주소를 참조하는 변수의 개수를 **참조 카운터**라고 함
- 참조 카운터가 0인 메모리 주소는 가비지 컬렉터의 수거 대상이 됨
- 가비지 컬렉터는 **런타임 환경**에 따라 **특정 시점이나 메모리 사용량이 포화상태에 이를 때마다** 자동으로 수거 대상을 수거함

### 변수 복사할 때 기본형과 참조형 비교

#### 기본형 데이터

```javascript
var a = 10
var b = a
```

- 변수 영역의 빈 공간 `@1002` 확보 후 식별자 `b`로 지정
- 식별자 `a` 검색(`@1001`)
- `@1001`에 저장된 값인 `@5001`을 `@1002`에 값으로 대입

#### 참조형 데이터

```javascript
var obj1 = { c: 10, d: 'ddd' }
var obj2 = obj1
```

- 변수 영역의 빈 공간 `@1004`을 확보 후 식별자 `obj2`로 지정
- 식별자 `obj1` 검색(`@1003`)
- `@1003`에 저장된 값인 `@5002`를 `@1004`에 값으로 대입

#### 복사 과정은 동일함

- 복사하는 과정은 기본형과 참조형 모두 같은 주소를 바라보게 되는 점에서 동일
- 복사 과정은 동일하지만 데이터 할당 과정에서 이미 차이가 있음
- 따라서 복사 이후 동작에도 큰 차이가 발생

### 변수 복사 이후 값 변경 결과 비교

#### 기본형 데이터

```javascript
var a = 10
var b = a
b = 15
```

- 데이터 영역에서 15를 검색 후 없으면 새로운 공간 `@5004`에 저장
- 변수 영역에서 식별자 `b`를 찾아 방금 15를 저장한 주소 `@5004`를 대입

#### 참조형 데이터

```javascript
var obj1 = { c: 10, d: 'ddd' }
var obj2 = obj1

obj2.c = 20
```

- 데이터 영역에서 20을 검색 후 없으면 새로운 공간 `@5005`에 저장
- 변수 영역에서 식별자 `obj2`를 검색(`@1004`)
- `obj2`의 값인 `@5002`가 가리키는 변수 영역에서 다시 `c`를 찾음(`@7103`)
- `@7103`에 `@5005` 대입

#### 뭐가 다르지?

- 기본형 데이터인 변수 a, b는 서로 다른 주소를 바라보게 됨
- 참조형 데이터인 변수 obj1, obj2는 여전히 같은 객체를 바라봄

```javascript
a !== b
obj1 === obj2
```

- 어떤 데이터 타입이든 변수에 할당하기 위해서는 주소값을 복사해야 함
- 따라서 엄밀히 따지면 자바스크립트의 모든 데이터 타입은 참조형 데이터일 수밖에 없음
- 다만 기본형은 주소값 복사를 한 번만 하고, 참조형은 한 단계를 더 거치는 차이가 있음
- **기본형도 결국 주소값을 참조함**

#### 객체 프로퍼티가 아닌 객체 자체를 변경하면?

```javascript
var a = 10
var b = a
var obj1 = { c: 10, d: 'ddd' }
var obj2 = obj1

b = 15
obj2 = { c: 20, d: 'ddd' }
```

- b와 마찬가지로 obj2에도 새로운 객체를 할당함으로써 값을 직접 변경함
- 메모리의 데이터 영역의 **새 공간에 새 객체가 저장**되고 그 주소를 변수 영역의 obj2 위치에 저장
- 객체에 대한 변경임에도 값이 달라짐
- 따라서 **참조형 데이터가 *"가변값"*이라고 설명할 때의 *"가변"*은 참조형 데이터 자체를 변경하는 경우가 아니라 그 내부의 프로퍼티를 변경할 때만 성립**

## 🦠 불변 객체

### 불변 책체를 만드는 방법

- 참조형 데이터도 데이터 자체를 변경하면 기본형 데이터와 마찬가지로 기존 데이터는 변하지 않음
- 내부 프로퍼티를 변경할 필요가 있을 때마다 **매번 새로운 객체를 만들어 재할당하면 객체 역시 불변성을 확보**할 수 있음

### 얕은 복사와 깊은 복사

#### 얕은 복사

- 바로 아래 단계의 값만 복사하는 방법
- 중첩 객체에서 참조형 데이터가 저장된 프로퍼티를 복사할 때 그 주소값만 복사한다는 의미
- 그러면 **해당 프로퍼티에 대한 원본과 사본이 동일한 참조형 데이터의 주소를 가리키게 됨**

```javascript
var user = {
  name: 'thumbsu',
  urls: {
    portfolio: 'https://thumbsu.dev/resume',
    blog: 'https://thumbsu.dev',
  },
}
```

- `user` 객체를 얕은 복사하면 `user` 객체에 직접 속한 프로퍼티는 복사해서 완전히 새로운 데이터가 만들어짐
- 한 단계 더 들어간 `urls`의 내부 프로퍼티들은 **기존 데이터를 그대로 참조**

#### 깊은 복사

- 내부의 모든 값들을 하나하나 찾아서 전부 복사하는 방법
- 참조형 데이터가 있을 때마다 재귀적으로 복사를 수행해야 비로소 깊은 복사가 됨

## 📭 undefined와 null

- `undefined`와 `null`은 자바스크립트에서 "없음"을 나타내는 두 가지 값
- 같은 것 같지만 미세하게 다르고, 사용하는 목적 또한 다름

### undefined

- 사용자가 명시적으로 지정
- 값이 존재하지 않을 때 자바스크립트 엔진이 자동으로 부여함

### 자바스크립트 엔진이 자동으로 undefined를 지정하는 경우?

- **사용자가 응당 어떤 값을 지정할 것이라고 예상하는 상황임에도 실제로는 그렇게 하지 않았을 때 undefined를 반환**

```javascript
var a

console.log(a)
```

- 값을 대입하지 않은 변수에 접근하려고 할 때

```javascript
var obj = { a: 1 }

console.log(obj.b)
```

- 객체 내부의 존재하지 않는 프로퍼티에 접근하려고 할 때

```javascript
var func = function() {}
var c = func()

console.log(c)
```

- return문이 없거나 호출되지 않는 함수의 실행 결과

### undefined와 배열

```javascript
var arr1 = []
arr1.length = 3

console.log(arr1) // [empty x 3]

var arr2 = new Array(3)
console.log(arr2) // [empty x 3]

var arr3 = [undefined, undefined, undefined]
console.log(arr3) // [undefined, undefined, undefined]
```

- `arr1`과 `arr2`는 `undefined`조차도 할당돼 있지 않음을 의미
- `arr1`과 `arr2`는 "비어있는 요소"
- "비어있는 요소"와 "undefined를 할당한 요소"는 출력 결과부터 다름
- "비어있는 요소"는 순회와 관련된 많은 배열 메서드들의 **순회 대상에서 제외**
- 어떠한 처리도 하지 않고 건너뜀
- **"배열도 객체"**임을 생각해보면 당연한 현상
- 객체와 마찬가지로 특정 인덱스에 값을 지정할 때 비로소 빈 공간을 확보하고 인덱스를 이름으로 지정하고 데이터의 주소값을 저장하는 등의 동작을 함
- 즉, **값이 지정되지 않은 인덱스는 "아직은 존재하지 않는 프로퍼티"에 지나지 않는 것**

### 사용자가 지정한 undefined와 엔진이 어쩔 수 없이 반환하는 undefined

- 전자의 `undefined`는 그 자체로 값
- "비어있음"을 의미하긴 하지만 하나의 값으로 동작
- **프로퍼티나 배열의 요소는 고유의 키값이 실존**하기 때문에 순회의 대상이 될 수 있음
- 후자는 **해당 프로퍼티 내지 배열의 키값 자체가 존재하지 않음**을 의미
- 후자는 우리의 통제 범위를 벗어나므로 모든 `undefined`가 오직 이 경우만 해당하게끔 해주면 됨

### "비어있음"을 명시적으로 나타내고 싶을 때

- `null`이라는 값이 있는데 굳이 `undefined`를 써야 할 이유가 없음
- `null`은 애초에 이런 용도로 만든 데이터 타입
- 이런 규칙을 따르는 한 **`undefined`는 오직 "값을 대입하지 않은 변수에 접근하고자 할 때 자바스크립트 엔진이 반환해주는 값"으로서만 존재**할 수 있음

### null 주의점

- `typeof null`이 `object`라는 점
- 자바스크립트 자체 버그
- 어떤 변수의 값이 null인지 여부를 판별하기 위해서는 typeof 대신 다른 방식으로 접근해야 함

```javascript
var n = null
console.log(typeof n) // object

console.log(n == undefined) // true
console.log(n == null) // true

console.log(n === undefined) // false
console.log(n === null) // true
```

- 일치 연산자(`===`)를 써야만 정확히 판별됨

## 🗂 정리

### 데이터 타입: 기본형 | 참조형

- 기본형은 불변값
- 참조형은 가변값

### 기본형은 할당이나 연산시 복제되고, 참조형은 참조된다?

- 엄밀히 말하면 둘다 복제됨
- but, 기본형은 **값이 담긴 주소값을 바로 복제**하고 참조형은 **값이 담긴 주소값들로 이루어진 묶음을 가리키는 주솟값**을 복제함

### 변수와 식별자

- 변수는 **변경 가능한 데이터가 담길 수 있는 공간**
- 식별자는 **그 변수의 이름**

### 변수 선언 후 과정

1. 메모리의 빈 공간에 식별자 저장
2. 그 공간의 값은 `undefined` 할당

### 변수에 데이터 할당 과정

- **기본형 데이터일 때**

  1. 별도의 공간에 데이터 저장
  2. 그 공간의 주소를 변수의 값 영역에 할당

- **참조형 데이터일 때**

  1. 참조형 데이터 내부 프로퍼티들을 위한 변수 영역을 확보
  2. 확보된 주소를 변수에 연결
  3. 확보된 변수 영역에 각 프로퍼티의 식별자 저장
  4. 각 데이터를 별도의 공간에 저장해서 그 주소를 식별자들과 매칭시킴

### 할당 과정에서 기본형과 차이가 생긴 이유

- 참조형 데이터는 **여러 개의 프로퍼티(변수)를 모은 그룹**이기 때문
- 이 차이로 인해 참조형 데이터를 **가변값**으로 여겨야 하는 상황 발생

### 참조형 데이터를 불변값으로 사용하는 방법

- 내부 프로퍼티들을 일일이 복사(**깊은 복사**)
- 혹은 라이브러리 사용

### "_없음_"을 나타내는 값은?

- `undefined`는 어떤 변수에 값이 존재하지 않을 경우를 의미
- `null`은 사용자가 명시적으로 *없음*을 표현하기 위해 대입한 값
- 본래의 의미헤 따라 사용자가 *없음*을 표현하기 위해 명시적으로 `undefined`를 대입하는 것은 지양하는 것이 좋음
